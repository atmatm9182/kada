#!/usr/bin/env sh
# -*- mode: scheme; -*-
# vim: ft=scheme
exec guile --no-auto-compile -e main -s "$0" "$@"
!#

(use-modules (ice-9 match)
             (ice-9 format)
             (ice-9 getopt-long)
             (srfi srfi-1)
             (kada db)
             (kada types))
;; (print
;;  (strftime "%c"
;;            (localtime
;;             (current-time))))

(define opts-spec
  '((date (single-char #\d) (value #t))
    (rev (single-char #\r) (value #f))))

(define main
  (match-lambda
    ((_)
     (error "No subcommand provided. Aborting."))
    ((all-args ...)
     (let* ((opts (getopt-long all-args opts-spec))
            (args (cdar opts)))
       (when (null? args)
         (error (format #f "No subcommand provided")))

       (match-let
         (((cmd args ...) args))
         (match (assoc cmd %cmd-handlers)
                (#f (error (format #f "Unrecognized subcommand '~a'" cmd)))
                ((_ . handler) (handler args (cdr opts)))))))))

(define-syntax define-handler
  (lambda (syn)
    (syntax-case
      syn ()
      ((_ name args-check flags-spec body ...)
       (with-syntax ((args (datum->syntax syn 'args))
                     (flags (datum->syntax syn 'flags)))
                    #`(define (name args flags)
                        (unless
                          #,(datum->syntax syn
                                           (reverse
                                             (cons
                                               (syntax->datum #'(length args))
                                               (reverse (syntax->datum #'args-check)))))
                          (error "Invalid number of arguments"))
                        (let* ((allowed-flags
                                 #,(list #'quote
                                         #'(syntax->datum flags-spec)))
                               (bad-flag
                                 (list-any? (match-lambda
                                              ((flag . value)
                                               (not (member
                                                      flag
                                                      allowed-flags))))
                                            flags)))
                          (when bad-flag
                            (error (format #f
                                           "Unrecognized flag '~a'"
                                           (car bad-flag))))
                          body ...)))))))

(define-handler
  item-enter
  (= 1)
  ()
  (let* ((name (car args))
         (last-mark (db-query-last-enter-mark))
         (mark (make-mark name (current-time) #f #t)))
    (when (and last-mark (equal? (mark-name last-mark) name))
      (error (format #f "Already entered span '~a'" name)))

    (db-insert-mark! mark)
    (format #t "Successfully created mark '~a'\n" name)))

(define-handler
  item-leave
  (= 0)
  ()
  (let ((last-mark (db-query-last-enter-mark)))
    (when (eq? last-mark #f)
      (error "There are no active marks"))

    (let ((name (mark-name last-mark)))
      (if (mark-enter? last-mark)
        (begin
          (db-insert-mark! (make-mark name
                                     (current-time)
                                     #f
                                     #f))
          (db-create-span! name)
          (format #t "Successfully created mark and span '~a'\n" name))
        (error (format #f "Last mark with name '~a' is not an entry mark" name))))))

(define-handler
  item-span
  (= 0)
  ()
  (let* ((spans (db-query-spans))
         (result (fold (lambda (span acc)
                         (string-append acc
                                        (span->string span)
                                        "\n"))
                       ""
                       spans)))
    (display (if (string-null? result)
               "There are no spans"
               result))))

(define %cmd-handlers
  `(("enter" . ,item-enter)
    ("leave" . ,item-leave)
    ("span" . ,item-span)))

;; Utility
(define (list-any? p xs)
  (match xs
         (() #f)
         ((x) (if (p x) x #f))
         ((kar kdr ...)
          (if (p kar)
            kar
            (list-any? p kdr)))))
